---
# ValidatingWebhookConfiguration for security validator webhooks
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: security-validator-webhooks
  annotations:
    argocd.argoproj.io/sync-wave: "2"
  labels:
    app.kubernetes.io/name: security-validator
    app.kubernetes.io/part-of: bookwork-security
webhooks:
  - name: validate-security-context.security.bookwork.com
    clientConfig:
      service:
        name: security-validator-service
        namespace: bookwork
        path: /validate-security-context
    namespaceSelector:
      matchLabels:
        name: bookwork
    rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: ["apps"]
        apiVersions: ["v1"]
        resources: ["deployments", "replicasets", "daemonsets", "statefulsets"]
      - operations: ["CREATE", "UPDATE"]
        apiGroups: [""]
        apiVersions: ["v1"]
        resources: ["pods"]
    admissionReviewVersions: ["v1"]
    failurePolicy: Ignore
    sideEffects: None

  - name: validate-secrets.security.bookwork.com
    clientConfig:
      service:
        name: security-validator-service
        namespace: bookwork
        path: /validate-secrets
    namespaceSelector:
      matchLabels:
        name: bookwork
    rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: [""]
        apiVersions: ["v1"]
        resources: ["secrets"]
      - operations: ["CREATE", "UPDATE"]
        apiGroups: ["bitnami.com"]
        apiVersions: ["v1alpha1"]
        resources: ["sealedsecrets"]
    admissionReviewVersions: ["v1"]
    failurePolicy: Ignore
    sideEffects: None

---
# Security Validator Service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: security-validator
  namespace: bookwork
  annotations:
    argocd.argoproj.io/sync-wave: "1"
  labels:
    app.kubernetes.io/name: security-validator
    app.kubernetes.io/part-of: bookwork-security
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: security-validator
  template:
    metadata:
      labels:
        app.kubernetes.io/name: security-validator
        app.kubernetes.io/part-of: bookwork-security
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 3000
        fsGroup: 2000
        seccompProfile:
          type: RuntimeDefault
      serviceAccountName: security-validator
      containers:
      - name: validator
        image: openpolicyagent/opa:0.57.0-envoy
        args:
        - "run"
        - "--server"
        - "--config-file=/config/config.yaml"
        - "/policies"
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
          runAsNonRoot: true
          runAsUser: 1000
        ports:
        - containerPort: 8181
          name: http
        volumeMounts:
        - name: config
          mountPath: /config
          readOnly: true
        - name: policies
          mountPath: /policies
          readOnly: true
        - name: tmp
          mountPath: /tmp
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: config
        configMap:
          name: security-validator-config
      - name: policies
        configMap:
          name: security-policies
      - name: tmp
        emptyDir:
          sizeLimit: 100Mi

---
# Service for the security validator
apiVersion: v1
kind: Service
metadata:
  name: security-validator-service
  namespace: bookwork
  labels:
    app.kubernetes.io/name: security-validator
    app.kubernetes.io/part-of: bookwork-security
spec:
  selector:
    app.kubernetes.io/name: security-validator
  ports:
  - name: https
    port: 443
    targetPort: 8181
    protocol: TCP

---
# ServiceAccount for security validator
apiVersion: v1
kind: ServiceAccount
metadata:
  name: security-validator
  namespace: bookwork
  labels:
    app.kubernetes.io/name: security-validator
    app.kubernetes.io/part-of: bookwork-security

---
# ClusterRole for security validator
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: security-validator
  labels:
    app.kubernetes.io/name: security-validator
    app.kubernetes.io/part-of: bookwork-security
rules:
- apiGroups: [""]
  resources: ["pods", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets", "daemonsets", "statefulsets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["bitnami.com"]
  resources: ["sealedsecrets"]
  verbs: ["get", "list", "watch"]

---
# ClusterRoleBinding for security validator
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: security-validator
  labels:
    app.kubernetes.io/name: security-validator
    app.kubernetes.io/part-of: bookwork-security
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: security-validator
subjects:
- kind: ServiceAccount
  name: security-validator
  namespace: bookwork

---
# ConfigMap with OPA configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: security-validator-config
  namespace: bookwork
  labels:
    app.kubernetes.io/name: security-validator
    app.kubernetes.io/part-of: bookwork-security
data:
  config.yaml: |
    decision_logs:
      console: true

---
# ConfigMap with security policies
apiVersion: v1
kind: ConfigMap
metadata:
  name: security-policies
  namespace: bookwork
  labels:
    app.kubernetes.io/name: security-validator
    app.kubernetes.io/part-of: bookwork-security
data:
  security.rego: |
    package kubernetes.admission

    # Deny on Pod create/update if the pod lacks a valid security context
    deny[msg] {
      input.request.kind.kind == "Pod"
      op := input.request.operation
      (op == "CREATE" )
      not valid_pod_security_context
      msg := "Pod must have valid security context with runAsNonRoot=true and restricted capabilities"
    }

    deny[msg] {
      input.request.kind.kind == "Pod"
      op := input.request.operation
      (op == "UPDATE" )
      not valid_pod_security_context
      msg := "Pod must have valid security context with runAsNonRoot=true and restricted capabilities"
    }

    # Deny on Deployment create/update if the deployment template lacks a valid security context
    deny[msg] {
      input.request.kind.kind == "Deployment"
      op := input.request.operation
      (op == "CREATE")
      not valid_deployment_security_context
      msg := "Deployment must have valid security context with runAsNonRoot=true and restricted capabilities"
    }

    deny[msg] {
      input.request.kind.kind == "Deployment"
      op := input.request.operation
      (op == "UPDATE")
      not valid_deployment_security_context
      msg := "Deployment must have valid security context with runAsNonRoot=true and restricted capabilities"
    }

    # Deny when creating/updating Secrets that look like plaintext sensitive data
    deny[msg] {
      input.request.kind.kind == "Secret"
      op := input.request.operation
      (op == "CREATE")
      contains_plain_text_secrets
      msg := "Secrets must not contain plain text sensitive data. Use SealedSecrets instead."
    }

    deny[msg] {
      input.request.kind.kind == "Secret"
      op := input.request.operation
      (op == "UPDATE")
      contains_plain_text_secrets
      msg := "Secrets must not contain plain text sensitive data. Use SealedSecrets instead."
    }

    # Validate pod security context: top-level and at least one container with hardened context
    valid_pod_security_context {
      spec := input.request.object.spec
      spec.securityContext.runAsNonRoot == true
      spec.securityContext.runAsUser > 0
      some i
      c := spec.containers[i]
      container_has_security_context(c)
    }

    # Validate deployment pod template security context
    valid_deployment_security_context {
      spec := input.request.object.spec.template.spec
      spec.securityContext.runAsNonRoot == true
      spec.securityContext.runAsUser > 0
      some i
      c := spec.containers[i]
      container_has_security_context(c)
    }

    container_has_security_context(container) {
      container.securityContext.allowPrivilegeEscalation == false
      container.securityContext.runAsNonRoot == true
      container.securityContext.capabilities.drop[_] == "ALL"
    }

    contains_plain_text_secrets {
      data := input.request.object.data
      some key
      value := data[key]
      contains(lower(key), "password")
      not startswith(value, "AgA")
    }

    contains_plain_text_secrets {
      data := input.request.object.data
      some key
      value := data[key]
      contains(lower(key), "secret")
      not startswith(value, "AgA")
    }

    contains_plain_text_secrets {
      data := input.request.object.data
      some key
      value := data[key]
      contains(lower(key), "token")
      not startswith(value, "AgA")
    }